---
layout:     post
title:      剑指Offer 11. 旋转数组的最小数字
subtitle:   
date:       2020-04-06
author:     Hao
header-img: img/post/post_bg_coffee.jpg
catalog: true
mathjax: true
tags:
    - 剑指Offer
---

#### 题目描述

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  

链接：[11. 旋转数组的最小数字](https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof)

#### 方法一

将旋转数组对半分可以得到一个包含最小元素的新旋转数组，以及一个非递减排序的数组。新的旋转数组的数组元素是原数组的一半，从而将问题规模减少了一半，这种折半性质的算法的时间复杂度为 O(logN)。\\
此时问题的关键在于确定对半分得到的两个数组哪一个是旋转数组，哪一个是非递减数组。我们很容易知道非递减数 组的第一个元素一定小于等于最后一个元素。\\
通过修改二分查找算法进行求解(l 代表 low，m 代表 mid，h 代表 high):\\
1) 当 nums[m] <= nums[h] 时，表示 [m, h] 区间内的数组是非递减数组，[l, m] 区间内的数组是旋转数组，此时 令 h = m; \\
2) 否则 [m + 1, h] 区间内的数组是旋转数组，令 l = m + 1。\\
当找到旋转点时结束，即high - low = 1，此时返回下标较大的元素。\\
如果数组元素允许重复，会出现一个特殊的情况: nums[l] == nums[m] == nums[h]，此时无法确定解在哪个区间，需要切换到顺序查找。例如对于数组 {1, 1, 1, 0, 1}，l、m 和 h 指向的数都为 1，此时无法知道最小数字 0 在哪个区间。

```java
public int minArray(int[] numbers) {
    int begin = 0, end = numbers.length-1;
    while (numbers[begin] >= numbers[end]) {
        if (end - begin == 1) {
            return numbers[end];
        }
        int pivot = (begin + end) / 2;
        if (numbers[begin] == numbers[pivot] && numbers[pivot] == numbers[end]) {
            return minVal(numbers, begin, end);
        }
        if (numbers[begin] <= numbers[pivot]) {
            begin = pivot;
        } else {
            end = pivot;
        }
    }
    return numbers[begin];
}

private int minVal(int[] nums, int begin, int end) {
    int result = nums[begin];
    for (int i = begin; i <= end; i++) {
        result = Math.min(result, nums[i]);
    }
    return result;
}
```